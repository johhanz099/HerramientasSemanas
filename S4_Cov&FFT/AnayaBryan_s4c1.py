# -*- coding: utf-8 -*-
"""AnayaBryan_S3C2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gIQWM7DpMEq7bLZOk_NHmala3zSGxntc
"""

import numpy as np
import matplotlib.pylab as plt

# Sistemas de ecuaciones lineales
N = 6
A = (np.random.random((N,N))*10.0)-5.0
B = (np.random.random((N,1))*10.0)-5.0

def Elim_Gauss(A,B):
    for i in range(A.shape[0]):    
        B[i] = B[i]/A[i,i]
        A[i,:] = A[i,:]/A[i,i]
        for j in range(i+1,A.shape[1]):
            B[j] = B[j] - B[i]*A[j,i]
            A[j,:] = A[j,:] - A[i,:]*A[j,i]
    x = np.zeros(A.shape[0])
    n = A.shape[1]
    for k in range(n-1,-1,-1):
        x[k] = B[k] - np.sum(A[k,:]*x)
        #print(x)
    return A,B,x

A_g,B_g,x = Elim_Gauss(A,B)
print("Solución <numérica>:",x)
print("Solución <verdadera>:",np.linalg.solve(A,B))

# Terminar eliminacion Gauss
# Matriz de cov

# Ejercicio2
t = np.array([0.,0.1,0.2,0.3,0.4,0.5,0.6, 0.8, 0.9])
u = np.array([-12.,-45.,-6.,-78.,-34.,-22.,10.,-31.,27.])
v = np.array([3.,11.,1.3,37.,11.,6.,-23.,7.,7.])

#2a) Graficar u(t),v(t)
Fig2a = plt.figure(figsize=(15,8))
ax1 = Fig2a.add_subplot(111)

ax1.plot(t,u,'r',label='Serie $u(t)$')
ax1.plot(t,v,'b',label='Serie $v(t)$')
ax1.set_title('Series $u,v$ en función del tiempo')
ax1.set_xlabel('t')
ax1.set_ylabel('$u,v$')
ax1.grid()
ax1.legend()

plt.savefig('serie.pdf')
plt.show()
plt.close()

#2b) Definir Cov_{u,v}
# Cov_{u,v} = \sum_{i=1}^{n} {(x_i-x_prom)(y_i-y_prom)} / (n-1)
def calc_cov(u,v):
    n1 = u.shape[0]
    n2 = v.shape[0]
    up,vp = np.mean(u), np.mean(v)
    if n1 != n2:
        return "Los vectores tienen diferente dimensión."
    elif n1 <= 1:
        return "No hay suficientes valores."
    else:
        r = np.sum((u-up)*(v-vp))
        return r / (n1-1)

#2c) Calcular Cov_{u,v}
print("Cov_{u,v} = ", calc_cov(u,v))

#2d) Calcular Var_{u}
# Dado que la varianza de una variable se define como
# Var_{u} = \sum_{i=1}^{n} {(x_i-x_prom)^2} / (n-1)
# Se puede calcular la varianza utilizando la función calc_cov(u,u)
print(" Var_{u} = ",calc_cov(u,u),'\n',
      "Var_{v} = ",calc_cov(v,v))



#2e) Crear función para crear matriz de covarianza
# [a00 a01
#  a10 a11]
# donde aij corresponde a Cov_{i,j}
def crear_M(x):
    n = x.shape[1] # cantidad de variables
    xm = np.zeros((n,n))
    for i in range(n):
        prom_col = np.mean(x[:,i])
        for j in range(n):
            xm[i,j] = np.sum((x[:,i]-prom_col)*(x[:,j])-np.mean(x[:,j]))
    xm = xm / (x.shape[0]-1)
    return xm

u_v = np.matrix.transpose(np.array([u,v]))
crear_M(u_v)

#data = np.genfromtxt('room-temperatures.csv')

np.cov(np.matrix.transpose(u_v))

u_v

data = np.genfromtxt('room-temperature.csv', skip_header = 1, delimiter = ',', usecols = (1,2,3,4))

#2e) Crear función para crear matriz de covarianza
# [a00 a01
#  a10 a11]
# donde aij corresponde a Cov_{i,j}
def crear_M(x):
    n = x.shape[1] # cantidad de variables
    xm = np.zeros((n,n))
    for i in range(n):
        prom_col = np.mean(x[:,i])
        for j in range(n):
            xm[i,j] = np.sum((x[:,i]-prom_col)*(x[:,j])-np.mean(x[:,j]))
    xm = xm / (x.shape[0]-1)
    return xm

M_cov = crear_M(data)
print("xxx")
print(M_cov)
print('Cov Func')
print(np.cov(data))

